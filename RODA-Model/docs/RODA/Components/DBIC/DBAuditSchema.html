<HTML>
<HEAD>
<TITLE>RODA::Components::DBIC::DBAuditSchema;</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<UL>
<LI><A HREF="#NAME">NAME

</A><LI><A HREF="#"></A><LI><A HREF="#INCARCARE">INCARCARE

</A><LI><A HREF="#FUNCTIONARE">FUNCTIONARE

</A><LI><A HREF="#METHODS">METHODS

</A><UL>
<LI><A HREF="#txn_do">txn_do

</A><LI><A HREF="#audit_init">audit_init

</A><LI><A HREF="#audit_commit">audit_commit

</A><LI><A HREF="#get_changes">get_changes

</A><LI><A HREF="#audit_log_create_changeset">audit_log_create_changeset

</A><LI><A HREF="#audit_log_create_action">audit_log_create_action

</A><LI><A HREF="#current_changeset">current_changeset

</A></UL>
</UL>
<HR>
<H1><A NAME="NAME">NAME

</A></H1>

<P>RODA::Components::DBIC::DBAuditSchema;

</P><H1><A NAME=""></A></H1>

<P>version 0.01

</P><H1><A NAME="INCARCARE">INCARCARE

</A></H1>

<P>In clasa schemei: 

</P>
<P>__PACKAGE__-&gt;load_components(qw/+RODA::Components::DBIC::DBAuditSchema/);


</P><H1><A NAME="FUNCTIONARE">FUNCTIONARE

</A></H1>

<P>Permite auditarea tabelelor prin inregistrarea modificarilor intr-o serie de tabele speciale

</P>
<P>Definirea coloanelor in clasele Result permite urmatoarele:

</P>
<PRE>  -evitarea auditarii unei coloane

    __PACKAGE__-&gt;add_columns(
           &quot;age&quot;,
          { data_type =&gt; &quot;integer&quot;, audit_log_column =&gt; 0 },
    );


  -fortarea auditarii unei coloane, chiar daca modificarile nu au atins-o

   __PACKAGE__-&gt;add_columns(
          &quot;age&quot;,
          { data_type =&gt; &quot;integer&quot;, audit_log_column =&gt; 0 },
    );</PRE>

<P>Pachetul permite de asemenea interceptarea valorii unor coloane inainte de audit si modificarea acestora, prin utilizarea atributului
modify_audit_value

</P>
<P>Variante de specificare a modificatorilor sunt urmatoarele:

</P>
<P>Trimiterea unei referinte la o subrutina anonima: 

</P>
<PRE>        __PACKAGE__-&gt;add_columns(
            &quot;+name&quot;,
            { modify_audit_value =&gt; sub{
                my ($self, $value) = @_;
                $value =~ tr/A-Z/a-z/;
                return $value;
            }, }
        );</PRE>

<P>trimiterea unui nume de subrutina si scrierea acesteia mai jos

</P>
<PRE>        __PACKAGE__-&gt;add_columns(
            &quot;+name&quot;,
            { modify_audit_value =&gt; 'to_lowercase'}, 
        );
        
        sub to_lowercase{
            my ($self, $value) = @_;
            $value =~ tr/A-Z/a-z/;
            return $value;
        }
</PRE>

<P>Pachetul injecteaza propriile metode in schema generala. Astfel, la executia unei tranzactii prin txn_do
metoda locala capteaza blocul de cod si seteaza o serie de variabile pentru a permite urmarirea tranzactiei. 

</P>
<P>In timpul rularii codului propriu-zis, metodele incarcate din RODA::Components::DBIC::DBAudit capteaza solicitarile de insert, update
delete si propaga inserarea datelor in tabelele de audit, folosind metodele adaugate la schema. 

</P>
<P>Apelarea txn_do permite adaugarea unei descrieri a tranzactiei

</P>
<PRE>        $roda-&gt;dbschema-&gt;txn_do(
            sub {
                $row-&gt;update({ ... });
            },
            {
                description =&gt; 'description of transaction' # optional
            }
        );</PRE>

<P>Apelarea txn_do pentru tabelele auditate TREBUIE sa fie autentificata, fie prin specificarea parametrului userid la conexiune:

</P>
<P>my $roda = RODA-&gt;new( configfile =&gt; $config, test =&gt; '1', userid=&gt;'1');

</P>
<P>fie prin setarea userid-ului ulterior conexiunii

</P>
<P>$roda-&gt;userid('3');


</P><H1><A NAME="METHODS">METHODS

</A></H1>
<H2><A NAME="txn_do">txn_do

</A></H2>

<P>txn_do se va executa inainte de txn_do din DBIx::Class. Verifica daca exista deja un changeset activ (pentru eventualitatea in care
s-a solicitat o tranzactie in interiorul altei tranzactii. Daca exista, trece mai departe, daca nu, va seta atributul _current_changeset_container
apoi trece mai departe la urmatorul txn_do din lantul de executie

</P><H2><A NAME="audit_init">audit_init

</A></H2>

<P>Pentru eventualitatea in care nu se doreste utilizarea tranzactiilor prin txn_do. In acest caz, toate executiile de pe durata de viata a schemei curente
se vor asocia unui singur changeset. Aceasta ase poate evita prin apelarea metodei audit_init care va initializa un changeset particular.

</P>
<P>Permite argumentul descriere, un string. 

</P><H2><A NAME="audit_commit">audit_commit

</A></H2>

<P>Inchide changesetul curent, permitand operatia non-tranzactionala cu mai multe changeseturi. Trebuie apelata doar daca a fost apelata audit_init

</P><H2><A NAME="get_changes">get_changes

</A></H2>

<P>Metoda generala de citire a modificarilor din tabelele de audit. Se apeleaza la nivel de schema

</P>
<PRE>    my $changes = $roda-&gt;dbschema-&gt;get_changes({table=&gt;'person', id=&gt;'8'});</PRE>

<P>Are nevoie de numele in clar al tabelului si de id-ul randului care trebuie urmarit. 

</P>
<P>Lista de argumente:

</P>
<PRE> id - id-ul randului din tabel pentru care se doreste auditul. Obligatoriu 
 table - tabelul de interes. Obligatoriu
 change_order - default desc, ordinea in care sunt returnate modificarile
 field - in lipsa specificarii unui camp, vor fi returnate toate campurile tabelului curent.
 timestamp - filtreaza dupa timestampul changeseturilor
 action_types - default este [ 'insert', 'update', 'delete' ], se poate inlocui cu o lista redusa
  
</PRE>
<H2><A NAME="audit_log_create_changeset">audit_log_create_changeset

</A></H2>

<P>Metoda care se ocupa de constructia unui changeset. Preia automat userid-ul din schema

</P><H2><A NAME="audit_log_create_action">audit_log_create_action

</A></H2>

<P>Metoda care se ocupa de verificarea existentei tabelului curent in tabelul audit_log_table si de crearea actiunii. 
O actiune este o modificare a unui rand de tabel. Apeleaza metoda current_changeset care
declanzeaza crearea changesetului (e un soi de checker). 

</P><H2><A NAME="current_changeset">current_changeset

</A></H2>

<P>Declanzeaza crearea changesetului (e un soi de checker). Daca nu gaseste nimic in _current_changeset_container va introduce un 
changeset netranzactional, setand descrierea sa fie: Non transactional changeset

</P>
</BODY>
</HTML>

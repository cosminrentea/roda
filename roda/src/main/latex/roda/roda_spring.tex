\section{Arhitectura generala a aplicatiei Spring}

Intr-o aplicatie web moderna, exista o separare clara intre layers /
nivele. O aplicatie ce utilizeaza Spring MVC (Spring 3.2.x) va avea cel putin
cele 3 nivele specifice unei aplicatii MVC, respectiv Model, Views, Controllers; 
suplimentar, aplicatia RODA are definit un nivel de servicii, 
care permite izolarea modelului fata de controllere si specificarea de drepturi de acces personalizate (prin ACL). 
Exista servicii disponibile expuse aplicatiei ca JavaBeans, precum cele pentru: 
indexare si cautare; file-repository; 
integrarea unui motor statistic; 
executia asincrona sau programata de task-uri etc.

%TODO Diagrame UML componente si clase ???

Pentru dezvoltare se utilizeaza IDE-ul STS
\footnote{\url{http://www.springsource.org/sts}}.
Initial, in primele etape ale proiectului a fost utilizt si Spring Roo
\footnote{\url{http://www.springsource.org/spring-roo}}
(care permite sincronizarea schema BD - model, sincronizarea model-controllers-views si generarea de
interfete web tip CRUD, adaugarea de servicii si componente, structurarea proiectului si generarea de configuratii).

Pentru mentinerea sincronizarii intre schema bazei de date si modelul generat
in Java, s-a utilizat in primele etape ale proiectului metoda \emph{Forward-Engineering}: 
pornindu-se de la un editor grafic al schemei bazei de date (DbWrench 2), %TODO URL ???
se obtine scriptul de creare a bazei de date, 
care este post-procesat si care este apoi folosit de Spring Roo pentru
actualizarea modelului domeniului.

\subsection{Modelul domeniului}
Pentru specificarea modelului domeniului - specific aplicatiei RODA, 
am utilizat specificatia JPA 2.0 (Java Persistence API).

Astfel, pornind de la schema bazei de date prezentate in raportul etapei 1 (ce
a suferit unele modificari pentru a se apropia de standardul DDI Codebook si
de Spring Security), sunt definite \emph{entitati} in sensul JPA 2.0; 
aceste Java Beans (ce compun pachetul \emph{ro.roda.domain}) 
sunt independente (fara relatii de mostenire),
iar fiecare entitate corespunde unui tabel din baza de date. 
Entitatile definite minimal aveau asociate 
aspecte de tipul Inter-Type Declaration (in fisiere AspectJ), 
ce erau (re-)generate automat de catre Spring Roo in timpul development-ului, 
pentru a permite roundtrip-ul intre schema bazei de date si modelul domeniului.
Odata cu etapa 3 a proiectului, s-a trecut de la o aplicatie Spring Roo 
la o aplicatie Spring 'pura', 
migrand functionalitatile din aspecte in codul Java; 
procesul de generare este in acest moment inversat - 
folosindu-se o abordare \emph{reverse-engineering}, respectiv: model -> baza de date. %TODO ??? sageata

Se folosesc in model adnotari specifice precum:
\begin{itemize}
  \item @Id
  \item @Table
  \item @Column
  \item @Transient
  \item adnotari pentru tipuri de relatii intre entitati %TODO detalii ???
\end{itemize}

Multe din aceste adnotari, metodele toString, 
getter/setter pentru campurile claselor etc., 
au fost generate in mod configurabil de catre Spring Roo.

Fiecare clasa din model expune si metode conform pattern-ului de utilizare \emph{Active Record}. 

\paragraph{Accesul aplicatiei la baza de date relationala}
Implementarea JPA 2.0 selectata pentru proiect este \emph{Hibernate}. 
%TODO versiunea in celalalt fisier ???
Hibernate este un pachet complex de tip \emph{Object-Relational Mapping};
in fisierul de configurare se specifica optiuni precum dialectul de SQL folosit
(in cazul aplicatiei RODA: Postgresql), 
clase ale modelului, 
modul de lucru (validate, create, create-drop, update), 
charset, 
setari pentru logging si formatarea SQL etc.

\emph{Hibernate Envers} asigura auditarea/versionarea entitatilor/tabelelor din
model (sunt create tabele specifice pentru auditare, intr-o alta schema a bazei
de date).

\paragraph{Datele disponibile initial in aplicatie}
Aplicatia poate fi configurata sa porneasca cu sau fara date initiale
disponibile.
Aceste date sunt importate din fisiere de tip \emph{comma-separated values} (CSV); 
se specifica ordinea de importare a acestor fisiere pentru a se respecta constrangerile relatiilor
dintre tabele/entitati.

\subsection{Servicii}
Nivelul de servicii permite 
\begin{itemize}
\item 
izolarea nivelului modelului (pentru accesul la
date s-ar putea folosi astfel, alternativ: JPA, sau JPA adaptat unui ORM sau
baze de date, sau o baza de date XML).
\item
definirea de reguli de acces la date(autorizare pe baza de ACL), modelul
ramanand astfel izolat de adnotari specifice Spring.
\end{itemize} 

Serviciile (perechi de interfete si implementari) folosesc 
metodele din pattern-ul \emph{Active Record} definite la nivelul modelului.

%TODO ??? extinderea serviciilor cu alte metode - helper, checkin, attach

\subsection{Controllere}
Sunt definite controllere corespunzand unui sablon de interfata de tip \emph{CRUD}
(Create / Read / Update / Delete), pentru fiecare clasa din model. 
In controllere se fac apeluri catre nivelul de servicii.

Au mai fost definite si controllere pentru a servi continut in format JSON;
aceste controllere sunt folosite de interfata ExtJS. 
%TODO pachetul Java folosit pentru JSON; URL JSON

\subsection{View-uri pe server}
Se utilizeaza o combinatie intre framework-ul de template-uri Apache Tiles %TODO URL
si pagini JSPX
(pagini JSP ce utilizeaza si librarii de tag-uri specifice Spring si Spring Roo, 
precum si framework-ul Dojo Toolkit pentru componente ale interfetei web).

\subsection{Interfata ExtJS}

%TODO despre interfata ???

%TODO URL extjs + versiune - in celalalt fisier

\section{Aspecte transversale in aplicatia Spring}
In aceasta sectiune descriem care sunt aspectele care apar in mod repetat la mai
multe niveluri diferite ale aplicatiei (precum configurari, logging
autentificare, servicii disponibile etc.).

\subsection{Fisiere de configurare a aplicatiei}
\label{fisiere_configurare}

% TODO integrarea celor 2 bucati de text de mai jos

Configurarea aplicatiei se face prin:
\begin {itemize}
\item Procedurile de build (Maven):
pom.xml
(aici se pot schimba si parametri: portul folosit de Tomcat la rularea aplicatiei; rularea sau nu a testelor etc.)
\item
fisiere de configurare a Spring: applicationContext.xml,
applicationContext-security.xml, applicationContext-acl.xml. 
Acestea configureaza Beans-urile din aplicatia Spring si proprietatile acestora, precum si Spring Security Authentication si Spring Security ACL.
\item
fisiere de configurare a aplicatiei web ce foloseste Spring Servlet:
web.xml
\item
fisiere de configurare a Spring MVC: 
webmvc-config.xml
\item
fisiere de configurare pentru sabloane/layout-uri Apache Tiles: 
layouts.xml, views.xml in foldere.
\item 
fisiere de configurare pentru Hibernate si JPA (de ex. modul de lucru: update / create / create-drop /
validate, auditare, setari logging, dialect SQL):
persistence.xml
\item
fisiere de tip 'properties', prin care pot suprascrie
inclusiv variabile definite in mediul de executie, si care sunt specifice modului de rulare a
aplicatiei (executie pe server, sau testare); de exemplu: 
\begin{description}
\item[Conexiunea la baza de date trebuie configurata in:]
database.properties
\item[Logging:]
log4j.properties
\item[Conexiunea cu serverul Solr:]
solr.properties
\item[Configurarea aplicatiei web RODA], inclusiv setarile pentru connection-pooling, pentru serverul de indexare
Solr, pentru integrarea R, pentru FileStore, pentru datele initiale disponibile
in aplicatie etc.:
roda.properties
\end{description}
\end{itemize}

\subsection{Logging}
Se foloseste Log4j, iar logger-ele sunt configurate ierarhic (cf. ierarhiei
pachetelor si claselor) si pe niveluri de detaliu, in fisierul de
configurare corespunzator.

\subsection{Autentificare}
Pentru autentificare este utilizata si adaptata solutia propusa de Spring Security.
Utilizatorii precum si hash-urile parolelor lor (SHA-256) sunt stocate in
tabele specifice din baza de date.

Se foloseste o schema de tipul 'users' / 'authorities'.
Din tabelul 'users' nu se sterg utilizatori, acestia pot fi insa dezactivati.
Tabelul 'users' este relationat cu alte tabele corespunzand modelului.

Spring Security are un design modular, si permite extinderea modelului de
securitate prin autentificarea cu LDAP si Shibboleth (SAML2).

\subsection{Autorizare}
Pentru autorizare este utilizata si adaptata solutia Spring Security.
Solutia de tip 'ACL' (Access Control Lists) utilizeaza implementari standard din
Spring Security (ACL ierarhic asupra diferitelor clase din model). 
Serviciile ce permit accesul la model sunt adnotate folosind SpEL
(Spring Expression Language).
Pentru a mari viteza de decizie este utilizata o solutie de caching (ehcache). 
Se face auditarea simpla a accesului (incercare, succes / esec). 

\subsection{Integrarea R}
Pentru implementarea acestui serviciu este folosit pachetul 'rJava/JRI'. %TODO Link = ???
Atunci cand acesta nu e disponibil pe host, serviciul care
incapsuleaza functionalitatile R este dezactivat.

\subsection{File Repository (FileStore)}
Acest serviciu stocheaza pe server fisierele incarcate de utilizatori, 
intr-o structura de directoare;
metadatele extrase din aceste fisiere sunt indexate.

\subsection{Indexare si Cautare}
Se utilizeaza un server Solr extern rulat pe un
Application Server pentru:
\begin{description}
\item[datele din BD] la creare/update/stergere de date din baza de
date
\item[metadatele extrase din fisiere] la upload-ul unui fisier
in FileStore (metadatele fiind disponibile ulterior aplicatiei web)
\end{description}

Schimburile de date intre aplicatia web si serverul Solr (de tip update, delete
etc.) se fac prin mijlocirea pachetului SolrJ, in mod asincron.

\subsection{Rularea asincrona sau programata a unor task-uri}
Operatiile prin care se interactioneaza cu serverul Solr sunt efectuate
asincron.
Componenta ce permite aceasta poate fi reutilizata si de catre alte
componente in scopul executiei asincrone a unor task-uri.

O alta posibilitate de executie intarziata este programarea task-urilor.
Folosind optiuni de configurare a momentelor de executie in stilul \emph{cron},
aceasta componenta este utila pentru task-uri ce nu trebuie declansate explicit de
utilizatori, precum mentenanta bazei de date sau efectuarea de backup-uri.

\section{Aspecte legate de dezvoltarea aplicatiei Spring}
In aceasta sectiune descriem aspectele legate de dezvoltarea in practica, intr-o
maniera incrementala si cu asigurarea calitatii procesului de dezvoltare.

\subsection{Documentare}
Se folosesc in codul-sursa comentarii de tip Javadoc. 

In procesul de build se genereaza automat documentatie de tip HTML;
pornind de la aceasta documentatie in format HTML, se poate genera si documentatie in format PDF 
folosind utilitarul \emph{htmldoc}.
%TODO detaliere htmldoc

\subsection{Testarea aplicatiei}
Testarea este realizata in acest moment prin 3 metode:
\begin{enumerate}
\item
testarea claselor din model, folosind \emph{JUnit} adaptat pentru Spring
\item
testarea controller-elelor printr-o suita de teste pentru interfata web de tip CRUD, 
teste ce au fost generate semi-automat
in limbajul \emph{Selenese} 
si executate prin \emph{Selenium}
\item
testarea aplicatiei web cu \emph{Selenium Server} si un client Perl executand
scripturi de testare scrise de echipa de dezvoltare
\end{enumerate}

\subsection{Procese de Build}
Procesele de build sunt realizate prin Maven;
fisierul de build aferent (\emph{pom.xml})
ce contine dependentele necesare pentru configurarea, compilarea,
deployment-ul, rularea, testarea, documentarea proiectului.

Serviciul de tip continuous-build (\emph{Jenkins}) 
realizeaza efectiv pasii descrisi mai sus 
atunci cand repository-ul SVN ce contine codul-sursa este modificat. 
%TODO detaliere job-uri Jenkins

In job-ul Jenkins aferent proiectului exista si pasi optionali pentru:
\begin{itemize}
\item
deployment al aplicatiei si remote pe un
serviciu de tip 'cloud' (\url{http://cloudfoundry.com}) 
\item
re-crearea schemei curente a bazei de date pe un server Postgresql intern,
pentru referinta.
\end{itemize}

%TODO pot fi generate URL-uri corecte, de ex. catre fisierele de configurare ce sunt hostate pe github ?!

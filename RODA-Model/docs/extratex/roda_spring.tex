\subsection{Arhitectura generala a aplicatiei Spring}

Intr-o aplicatie web moderna, exista o separare clara intre layers /
nivele. O aplicatie ce utilizeaza Spring MVC (Spring 3.2.x) va avea cel putin
cele 3 nivele specifice unei aplicatii MVC, respectiv Model, Views, Controllers; suplimentar,
aplicatia RODA are definit un nivel de servicii, care permite izolarea modelului
de controllere si specificarea de drepturi de acces personalizate (prin ACL). In
plus, exista servicii disponibile expuse aplicatiei ca JavaBeans: indexare si
cautare; file-repository; integrarea unui motor statistic; executia asincrona
sau programata de task-uri etc.

%Diagrame UML componente si clase ???

Pentru dezvoltare se utilizeaza IDE-ul STS
\footnote{\href{http://www.springsource.org/sts}{http://www.springsource.org/sts}}
si Spring Roo
\footnote{\href{http://www.springsource.org/spring-roo}{http://www.springsource.org/spring-roo}}
(care permite sincronizarea schema BD - model, sincronizarea model-controllers-views si generarea de
interfete CRUD, adaugarea de servicii si componente,generarea de configuratii
best-practice).

Pentru mentinerea sincronizarii intre schema bazei de date si modelul generat
in Java, se face Forward-Engineering; se porneste de la un editor grafic al
schemei bazei de date (DbWrench 2), se obtine scriptul de creare a bazei de
date, care este post-procesat si care este apoi folosit de Spring Roo pentru
actualizarea modelului.

\subsubsection{Modelul domeniului specific aplicatiei}
Se foloseste pentru descrierea modelului specificatia JPA 2.0 (Java Persistence
API).
Astfel, pornind de la schema bazei de date prezentate in raportul etapei 1 (ce
a suferit unele modificari pentru a se apropia de standardul DDI Codebook si
de Spring Security), sunt definite entitati in sensul JPA 2.0; aceste Java Beans
(pachetul 'domain') sunt independente (fara relatii de mostenire), o parte din ele
implementand interfata Serializable, si avand fisiere aferente de tip AspectJ
(re-)generate automat de catre Spring Roo in timpul development-ului.

Se folosesc in model adnotari specifice precum:
\begin{itemize}
  \item @Id
  \item @Table
  \item @Column
  \item @Transient
  \item adnotari pentru tipuri de relatii intre entitati
\end{itemize}

Multe din aceste adnotari, metodele toString, getter/setter pentru
campurile claselor, sunt generate in mod configurabil de catre Spring Roo.
Fiecare clasa din model expune si metode conform pattern-ului 'ActiveRecord'. 

\paragraph{Acces la baza de date relationala}
Implementarea JPA selectata pentru proiect este Hibernate (versiunea 4.2).
\begin{description}
\item[Hibernate] este un pachet complex de tip 'Object-Relational Mapping';
in fisierul de configurare se specifica optiuni precum dialectul de SQL folosit
(tipul de server de baze de date - in cazul RODA: Postgresql), clase ale
modelului, modul de lucru (validate, create, create-drop, update), 
charset, setari de logging si formatare etc.
\item[Hibernate Envers] asigura auditarea/versionarea entitatilor/tabelelor din
model (sunt create tabele specifice pentru auditare, intr-o alta schema a bazei
de date)
\end{description}

\paragraph{Date disponibile initial in aplicatie}
Aplicatia poate fi configurata sa porneasca cu sau fara date initiale
disponibile.
Aceste date sunt importate din fisiere de tip CSV; se specifica ordinea de
importare a acestor fisiere pentru a se respecta constrangerile relatiilor
dintre tabele/entitati.

\subsubsection{Services}
Nivelul de servicii permite 
\begin{itemize}
  \item izolarea nivelului modelului (pentru accesul la
date s-ar putea folosi astfel, alternativ: JPA, sau JPA adaptat unui ORM sau
baze de date, sau o baza de date XML)
  \item definirea de reguli de acces la date(autorizare pe baza de ACL), modelul
  ramanand astfel izolat de adnotari specifice Spring.
\end{itemize} 
Serviciile (perechi de interfete si implementari) folosesc 
metodele de tip ActiveRecord definite la nivelul modelului.

\subsubsection{Controllers}
Sunt definite controllere corespunzand unui sablon de interfata de tip CRUD
(Create / Read / Update / Delete), pentru fiecare clasa din model. In
controllere se fac apeluri catre nivelul de servicii.

\subsubsection{Views}
Se utilizeaza o combinatie intre Apache Tiles (templating framework) si JSPX
(pagini JSP utilizand librarii de tag-uri specifice).

\subsection{Aspecte transversale in aplicatia Spring}
In aceasta sectiune descriem care sunt aspectele care apar in mod repetat la mai
multe niveluri diferite ale aplicatiei (precum configurari, logging
autentificare, servicii disponibile etc.).

\subsubsection{Fisiere de configurare a aplicatiei}
\label{fisiere_configurare}

% TODO integrarea celor 2 bucati de text de mai jos

Configurarea aplicatiei se face prin:
\begin {itemize}
  \item fisiere de tip 'properties', prin care pot suprascrie
inclusiv variabile definite in mediul de executie, si care sunt specifice modului de rulare a
aplicatiei (executie pe server, sau testare); de exemplu: setarile de acces la
baza de date, setarile pentru connection-pooling, pentru serverul de indexare
Solr, pentru integrarea R, pentru FileStore, pentru datele initiale disponibile
in aplicatie etc.
  \item fisiere de configurare a Spring: applicationContext.xml,
  applicationContext-security.xml, applicationContext-acl.xml. Acestea
  configureaza Beans-urile din aplicatia Spring si proprietatile acestora.
  \item fisiere de configurare a Spring MVC: webmvc-config.xml
  \item fisiere de configurare a aplicatiei web ce foloseste Spring Servlet:
  web.xml
  \item fisiere de configurare pentru view-uri (Apache Tiles: views.xml,
  layouts.xml).
\end{itemize}

Mai precis:
\begin{description}
\item[Conexiunea la baza de date trebuie configurata in:]
src/main/resources/META-INF/spring/database.properties
\item[Hibernate si JPA] (de ex. modul de lucru: update / create / create-drop /
validate, auditare, setari logging, dialect DB):
src/main/resources/META-INF/persistence.xml
\item[Logging:]
src/main/resources/log4j.properties
\item[Spring (setup, JavaBeans, properties-handling etc.):]
src/main/resources/META-INF/spring/applicationContext.xml
\item[Spring Security Authentication:]
src/main/resources/META-INF/spring/applicationContext-security.xml
\item[Spring Security ACL:]
src/main/resources/META-INF/spring/applicationContext-acl.xml
\item[Conexiunea cu serverul Solr:]
src/main/resources/META-INF/spring/solr.properties
\item[Configurarea aplicatiei web RODA:]
src/main/resources/META-INF/spring/roda.properties
\item[Procedurile de build (Maven):]
/pom.xml
(aici se pot schimba si parametri: portul folosit de Tomcat la rularea aplicatiei; rularea sau nu a testelor etc.)
\end{description}

\subsubsection{Logging}
Se foloseste Log4j, iar logger-ele sunt configurate ierarhic (cf. ierarhiei
pachetelor si claselor) si pe niveluri de detaliu, in fisierul de
configurare.

\subsubsection{Autentificare}
Pentru autentificare este utilizata si adaptata solutia Spring Security.
Utilizatorii precum si hash-urile parolelor lor (SHA-256) sunt stocate in
tabele specifice din baza de date.

Se foloseste o schema de tipul 'users' / 'authorities'.
Din tabelul 'users' nu se sterg utilizatori, acestia pot fi dezactivati.
Tabelul 'users' este relationat cu alte tabele corespunzand modelului.

Spring Security are un design modular, si permite extinderea modelului de
securitate prin autentificarea cu LDAP si Shibboleth (SAML2).

\subsubsection{Autorizare}
Pentru autorizare este utilizata si adaptata solutia Spring Security.
Solutia de tip 'ACL' (Access Control Lists) utilizeaza implementari standard din
Spring Security (ACL ierarhic asupra diferitelor clase din model). 
Serviciile ce permit accesul la model sunt adnotate folosind SpEL
(Spring Expression Language).
Pentru a mari viteza de decizie este utilizata o solutie de caching (ehcache). 
Se face auditarea simpla a accesului (incercare, succes / esec). 

\subsubsection{Integrarea R}
Pentru implementarea acestui serviciu sste folosit pachetul 'rJava/JRI'. 
Atunci cand acesta nu e disponibil pe host, serviciul care
incapsuleaza functionalitatile R este dezactivat.

\subsubsection{File Repository (FileStore)}
Acest serviciu respecta interfetele definite prin RODA::FileStore, stocand
fisierele incarcate de utilizatori intr-o structura de directoare pe server;
metadatele extrase din aceste fisiere sunt indexate.

\subsubsection{Indexare si Cautare}
Se utilizeaza un server Solr extern (versiunea curenta: 4.2) rulat pe un
application server pentru:
\begin{description}
\item[datele din BD] la creare/update/stergere de date din tabelele bazei de
date
\item[metadatele extrase din fisiere] la upload-ul unui fisier
in FileStore (metadatele fiind disponibile ulterior aplicatiei web)
\end{description}

Schimburile de date intre aplicatia web si serverul Solr (de tip update, delete
etc.) se fac prin mijlocirea pachetului SolrJ, in mod asincron.

\subsubsection{Rularea asincrona sau programata a unor task-uri}
Operatiile prin care se interactioneaza cu serverul Solr sunt efectuate
asincron. Componenta ce permite aceasta poate fi reutilizata si de catre alte
componente in scopul executiei asincrone de task-uri.

O alta posibilitate de executie intarziata este programarea task-urilor.
Folosind optiuni de configurare a momentelor de executie in stilul 'cron',
aceasta componenta este utila pentru task-uri ce nu sunt declansate explicit de
utilizatori, precum mentenanta bazei de date sau efectuarea de backup-uri.

\subsubsection{Documentare}
Se folosesc in codul-sursa comentarii de tip Javadoc. 

In procesul de build se genereaza automat documentatie  de tip HTML. 
De asemenea, prin utilitarul 'htmldoc' se poate genera
si documentatie in format PDF pornind de la aceasta documentatie in format HTML.
%TODO detaliere htmldoc

\subsection{Aspecte legate de dezvoltarea aplicatiei Spring}
In aceasta sectiune descriem aspectele legate de dezvoltarea in practica, intr-o
maniera incrementala si cu asigurarea calitatii procesului de dezvoltare.

\subsubsection{Testarea aplicatiei}
Testarea este realizata in acest moment prin 3 metode:
\begin{enumerate}
  \item testarea claselor din model, folosind JUnit adaptat pentru Spring
  \item testarea controller-elelor printr-o suita de teste generate semi-automat
  in limbajul Selenese si executate prin Selenium
  \item testarea aplicatiei web cu Selenium Server si un client Perl executand
  scripturi de testare
\end{enumerate}

\subsubsection{Build si Deployment}
Procesele de build sunt realizate prin Maven 3. Fisierul aferent (pom.xml)
contine dependentele necesare pentru configurarea, compilarea,
deploymentul, rularea, testarea, documentarea proiectului.

Procesul de build continuu este realizat prin 
serviciul de tip continuous-build (Jenkins), 
care realizeaza efectiv pasii descrisi mai sus 
atunci cand repository-ul SVN continand codul-sursa este modificat. 
%TODO detaliere job-uri Jenkins

Se face deployment al aplicatiei si remote pe un
serviciu de tip 'cloud' (cloudfoundry.com), 
iar schema curenta a bazei de date este creata pe un server Postgresql intern,
pentru referinta.
